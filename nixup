#! /usr/bin/env bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
set -euo pipefail
set -x

unset NIX_PATH
cd "${DIR}"

cache="colemickens"
niche_cache="https://azdev2020nov.blob.core.windows.net/nixcache"
cachixpkgs="https://github.com/nixos/nixpkgs/archive/nixos-20.09.tar.gz" # where to find pkgs.cachix
unstablepkgs="https://github.com/nixos/nixpkgs/archive/nixos-unstable.tar.gz" # where to find nixUnstable
nichepkgs="https://github.com/colemickens/niche/archive/$(cd ~/code/niche; git rev-parse HEAD).tar.gz" # where to find niche + all nixpkgs
set +x; cachixkey="$(cat ~/.config/cachix/cachix.dhall | grep eIu | cut -f 2 -d '"' || echo "")"; set -x

nixargs=(--experimental-features "nix-command flakes ca-references recursive-nix")

buildargs=(
  --option 'extra-binary-caches' 'https://cache.nixos.org https://colemickens.cachix.org https://nixpkgs-wayland.cachix.org'
  --option 'trusted-public-keys' 'cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= colemickens.cachix.org-1:bNrJ6FfMREB4bd4BOjEN85Niu8VcPdQe4F4KxVsb/I4= nixpkgs-wayland.cachix.org-1:3lwxaILxMRkVhehr5StQprHdEo4IrE8sRho9R9HOLYA='
  --option 'build-cores' '0'
  --option 'narinfo-cache-negative-ttl' '0'
)

srcdirs=(
  "$HOME/code/nixpkgs/master"
  "$HOME/code/nixpkgs/cmpkgs"
  "$HOME/code/home-manager/cmhm"
  "$HOME/code/nixpkgs-wayland"
  "$HOME/code/flake-firefox-nightly"
  "$HOME/code/mobile-nixos"
  #"$HOME/code/nixos-veloren"
  #"$HOME/code/nixos-azure"
  "$HOME/code/sops-nix"
  "$HOME/code/wip-pinebook-pro"
)
evalargs=()

function update() {
  set -euo pipefail
  set +x; printf "\n\n%s\n" ":::::::: updating all (local, override) inputs" &>/dev/stderr; set -x
  for sdir in "${srcdirs[@]}"; do
      cd "$sdir"
      git pull --rebase && git push origin HEAD -f || false
  done
  cd ~/code/nixcfg
  set +x; printf "\n\n%s\n" ":::::::: updating all inputs" &>/dev/stderr; set -x
  nix flake update --recreate-lock-file --no-registries
  set +x; printf "\n\n%s\n" ":::::::: updating our own packages" &>/dev/stderr; set -x
  cd "./pkgs" && ./update.sh;
  set +x; printf "\n\n%s\n" ":::::::: stashing nixcfg" &>/dev/stderr; set -x
  cd -; cd ~/code/nixcfg; git add -A . && (git commit -m stash && git pull --rebase && git push origin HEAD -f || false) || true
  cd -;
}
# this includes the actual `cachix push` command, just send it a path
function ssh_cachix_push() {
  set -euo pipefail
  ssh "${1}" "nix-shell -I nixpkgs=${cachixpkgs} -p cachix --run \
    'echo ${2} | env CACHIX_SIGNING_KEY=${cachixkey} cachix push ${cache} >/dev/stderr'" &>/dev/stderr
}
# this just wraps the shell, give it the full command: ssh_nixUnstable_shell nix build ...
function ssh_nixUnstable_shell() {
  local r="${1}"; shift;
  ssh "${r}" -- "nix-shell -I nixpkgs=${unstablepkgs} -p nixUnstable --run '$(printf '\"%s\" ' "${@}")'"
}
# this just wraps the shell, give it the full command: ssh_niche_shell niche build ...
function ssh_niche_shell() {
  local r="${1}"; shift;
  ssh "${r}" -- "nix-shell -I nixpkgs=${nichepkgs} -p niche -p gnupg -p nixUnstable --command 'NICHE_DEBUG=1 $(printf '\"%s\" ' "${@}")'"
}

function build() {
  set -euo pipefail
  thing="${1}"; shift
  remote="${1}"; shift
  target="${1:-"${USER}@localhost"}"; shift

  # LOCAL: eval the out to be able to check for substitute
  set +x; printf "\n\n%s\n" ":::::::: eval ${thing}" &>/dev/stderr; set -x
  drv="$(set -euo pipefail; nix "${nixargs[@]}" eval "${evalargs[@]}" --raw "${thing}.drvPath" | tr -d '"')"
  out="$(set -euo pipefail; nix "${nixargs[@]}" path-info "${drv}" --json | jq -r '.[0].path')"

  # TARGET: short circuit if we can realize $out on $target
  set +x; printf "\n\n%s\n" ":::::::: TARGET: short circuit if we can realize $out on $target" &>/dev/stderr; set -x;
  if ssh_nixUnstable_shell "${target}" nix "${nixargs[@]}" build "${buildargs[@]}" -j0 "${out}"; then
    echo -e "${out}"; return 0
  fi

  # LOCAL: copy drvs to tmp
  local t="/tmp/tmpnixpath"
  nix "${nixargs[@]}" copy --to "file://${t}" --derivation "${drv}"

  # LOCAL: rsync $t to $remote
  set +x; printf "\n\n%s\n" ":::::::: LOCAL: rsync $t to $remote" &>/dev/stderr
  rsync -ah "${t}/" "${remote}:${t}"

  # REMOTE: copy drvs to store
  set +x; printf "\n\n%s\n" ":::::::: REMOTE: copy $drv => /nix/store" &>/dev/stderr
  ssh_nixUnstable_shell "${remote}" nix "${nixargs[@]}" copy --from file://${t} --derivation ${drv}

  # REMOTE: build $drv => $out
  set +x; printf "\n\n%s\n" ":::::::: REMOTE: build $drv => $out" &>/dev/stderr; set -x
####
  ssh_nixUnstable_shell "${remote}" nix "${nixargs[@]}" build -L "${buildargs[@]}" --keep-going "${drv}"
####
  #ssh_niche_shell "${remote}" niche build -u "${niche_cache}" -- -L "${nixargs[@]}"  "${buildargs[@]}" --keep-going "${drv}"
####

  if [[ ! -z "${cachixkey:-""}" ]]; then
    # REMOTE: push $out to cachix
    set +x; printf "\n\n%s\n" ":::::::: REMOTE: push $out to cachix" &>/dev/stderr

# this includes the actual `cachix push` command, just send it a path
    ssh_cachix_push "${remote}" "${out}"
  fi

  # if we didn't list a target, we're just pushing the build up, we can be done
  if [[ -z "${target:-""}" ]]; then
  # this just wraps the shell, give it the full command: ssh_nixUnstable_shell nix build ...
    echo -e "${out}"; return 0
  fi

  if [[ ! -z "${cachixkey:-""}" ]]; then
  # this just wraps the shell, give it the full command: ssh_niche_shell niche build ...
    # TARGET: copy $out from cachix (on $target)
    set +x; printf "\n\n%s\n" ":::::::: TARGET: copy $out from cachix (on $target)" &>/dev/stderr
    if ssh_nixUnstable_shell "${target}" nix "${nixargs[@]}" build "${buildargs[@]}" -j0 "${out}"; then
      echo -e "${out}"; return 0
    fi
  else
    # TARGET: copy $out from $remote (on $target)
    set +x; printf "\n\n%s\n" ":::::::: TARGET: copy $out from $remote (on $target)" &>/dev/stderr
    if ssh -A "${target}" "$(printf '\"%s\" ' nix copy --from "ssh://${remote}" "${out}")"; then
      echo -e "${out}"; return 0
    fi
  fi

  # if we still cna't realize on device,
  # see if we can realize here and then push to device
  # (this applies for blueline where we cant pull but can be pushed to)
  if [[ ! -z "${cachixkey:-""}" ]]; then
    # LOCAL: copy $out from cachix
    set +x; printf "\n\n%s\n" ":::::::: LOCAL: copy $out from cachix" &>/dev/stderr
    nix "${nixargs[@]}" build "${buildargs[@]}" "${thing}" -j0
  else
    # LOCAL: copy $out from $remote
    set +x; printf "\n\n%s\n" ":::::::: LOCAL: copy $out from $remote" &>/dev/stderr
    nix "${nixargs[@]}" copy --from "ssh://${remote}" "${out}"
  fi

  # LOCAL: copy $out to $target
  set +x; printf "\n\n%s\n" ":::::::: LOCAL: copy $out to $target" &>/dev/stderr
  nix "${nixargs[@]}" copy --to "ssh://${target}" "${out}"

  echo -e "${out}"; return 0
}

function activate() {
  set -euo pipefail
  bo="$(set -euo pipefail; build "${@}")"
  target="${3:-"cole@localhost"}"
  spz="${4:-""}"

  ssh -A "${target}" "$(printf '\"%s\" ' sudo nix build --profile /nix/var/nix/profiles/system "${bo}")";
  if [[ "${spz}" == "" ]]; then
    ssh -A "${target}" "$(printf '\"%s\" ' sudo nix shell -vv "${bo}" -c switch-to-configuration switch)";
  else
    ssh -A "${target}" "$(printf '\"%s\" ' sudo nix shell -vv "${bo}" -c ${bo}/specialisation/${spz}/bin/switch-to-configuration switch)";
  fi
}

function rpione()     { activate ".#toplevels.rpione"      "colemickens@aarch64.nixos.community"         "cole@192.168.1.2";        }
function rpitwoboot() { build ".#images.rpitwoboot"        "colemickens@aarch64.nixos.community"         "cole@localhost";          }
function rpitwoefi()  { build ".#images.newimg"            "colemickens@aarch64.nixos.community"         "cole@localhost";          }
function pinebook()   { if [[ "$(hostname)" != "pinebook" ]]; then exit 1; fi; activate ".#toplevels.pinebook"    "cole@localhost"         "cole@localhost" sway-unstable; }
#function pinebook()   { activate ".#toplevels.pinebook"    "colemickens@aarch64.nixos.community"         "cole@192.168.1.155" sway; }
function aarch64()    { build    ".#bundles.aarch64-linux" "colemickens@aarch64.nixos.community"         "cole@localhost";          }
function x86()        { build    ".#bundles.x86_64-linux"  "cole@azdev2020vm.westus2.cloudapp.azure.com" "cole@localhost";          }

function a64() { build "$1" "colemickens@aarch64.nixos.community" "colemickens@aarch64.nixos.community"; }

function niche() {
  # this is just to test niche out the way this wrapper expects to be able to call it
  ssh_niche_shell 'cole@localhost' \
    niche build -u "${niche_cache}" -- 'github:colemickens/flake-impure' --impure
}

if [[ ! -z "${1:-""}" ]]; then cmd="${1}"; shift; fi

if [[ ! -z "${cmd:-""}" ]]; then
  "${cmd}" "${@}"
else
  set -euo pipefail
  update
  activate ".#toplevels.$(hostname)" "cole@localhost" "cole@localhost" sway
fi
