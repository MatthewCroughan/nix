#! /usr/bin/env bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
set -euo pipefail
set -x

# ❯ ./nixup build .#bundles.aarch64-linux colemickens@aarch64.nixos.community cole@localhost
# ❯ ./nixup build .#bundles.x86_64-linux cole@azdev2020vm.westus2.cloudapp.azure.com cole@localhost

unset NIX_PATH
cd "${DIR}"

cache="colemickens"
niche_cache="https://azdev2020nov.blob.core.windows.net/nixcache"
cachixpkgs="https://github.com/nixos/nixpkgs/archive/nixos-20.09.tar.gz" # where to find pkgs.cachix
#unstablepkgs="https://github.com/nixos/nixpkgs/archive/nixos-unstable.tar.gz" # where to find nixUnstable
unstablepkgs="https://github.com/colemickens/nixpkgs/archive/cb7279c5511.tar.gz" # where to find nixUnstable
cachixkey="$(set -e; gopass show "websites/cachix.org/apikey/${cache}")"

nixargs=(--experimental-features "nix-command flakes ca-references recursive-nix")
# TODO: research post-build hooks?
buildargs=(
  --option 'extra-binary-caches' 'https://cache.nixos.org https://colemickens.cachix.org https://nixpkgs-wayland.cachix.org'
  --option 'trusted-public-keys' 'cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= colemickens.cachix.org-1:bNrJ6FfMREB4bd4BOjEN85Niu8VcPdQe4F4KxVsb/I4= nixpkgs-wayland.cachix.org-1:3lwxaILxMRkVhehr5StQprHdEo4IrE8sRho9R9HOLYA='
  --option 'build-cores' '0'
  --option 'narinfo-cache-negative-ttl' '0'
)
evalargs=(
  #--impure
  # --override-input master "/home/cole/code/nixpkgs/master"
  # --override-input nixpkgs "/home/cole/code/nixpkgs/cmpkgs"
  # --override-input pipkgs "/home/cole/code/nixpkgs/pipkgs"
  # --override-input firefox "/home/cole/code/flake-firefox-nightly"
  # --override-input home-manager "/home/cole/code/home-manager/cmhm"
  # --override-input mobile-nixos "/home/cole/code/mobile-nixos"
  # --override-input nixos-azure "/home/cole/code/nixos-azure"
  # --override-input nixos-veloren "/home/cole/code/nixos-veloren"
  # --override-input nixpkgs-wayland "/home/cole/code/nixpkgs-wayland"
  # --override-input sops-nix "/home/cole/code/sops-nix"
  # --override-input wip-pinebook-pro "/home/cole/code/wip-pinebook-pro"
)

function update() {
  set -euo pipefail

  set +x; printf "\n\n%s\n" ":::::::: updating all (local, override) inputs" &>/dev/stderr; set -x
    cd ~/code/nixpkgs/master; git remote update; git reset --hard "nixpkgs/master" && git push origin HEAD -f || false
  cd -; cd ~/code/nixcfg;                git pull --rebase && git push origin HEAD -f || false
  #cd -; cd ~/code/nixpkgs/cmpkgs;        git pull --rebase && git push origin HEAD -f || false
  #cd -; cd ~/code/nixpkgs/pipkgs;        git pull --rebase && git push origin HEAD -f || false
  cd -; cd ~/code/flake-firefox-nightly; git pull --rebase && git push origin HEAD -f || false
  #cd -; cd ~/code/nixpkgs-wayland;       git pull --rebase && git push origin HEAD -f || false
  cd -; cd ~/code/home-manager/cmhm;     git pull --rebase && git push origin HEAD -f || false
  cd -; cd ~/code/mobile-nixos;          git pull --rebase && git push origin HEAD -f || false
  cd -; cd ~/code/nixos-azure;           git pull --rebase && git push origin HEAD -f || false
  #cd -; cd ~/code/nixos-veloren;         git pull --rebase && git push origin HEAD -f || false
  cd -; cd ~/code/sops-nix;              git pull --rebase && git push origin HEAD -f || false
  cd -; cd ~/code/wip-pinebook-pro;      git pull --rebase && git push origin HEAD -f || false; cd -

  set +x; printf "\n\n%s\n" ":::::::: updating all inputs" &>/dev/stderr; set -x
  nix flake update --recreate-lock-file --no-registries

  set +x; printf "\n\n%s\n" ":::::::: updating our own packages" &>/dev/stderr; set -x
  cd "./pkgs" && ./update.sh;
  cd -;
}
function ssh_cachix_path() {
  set -euo pipefail
  ssh "${1}" "nix-shell -I nixpkgs=${cachixpkgs} -p cachix --run \
    'echo ${2} | env CACHIX_SIGNING_KEY=${cachixkey} cachix push ${cache} >/dev/stderr'" &>/dev/stderr
}
function ssh_nix_unstable() {
  local r="${1}"; shift;
  ssh "${r}" -- "nix-shell -I nixpkgs=${unstablepkgs} -p nixUnstable --run '$(printf '\"%s\" ' "${@}")'"
}
function ssh_niche_build() {
  local r="${1}"; shift;
  ssh "${r}" -- "nix-shell -I nixpkgs=${unstablepkgs} -p niche -p nixUnstable --run '$(printf '\"%s\" ' "${@}")'"
}

function build() {
  set -euo pipefail
  thing="${1}"; shift
  remote="${1}"; shift
  target="${1:-"${USER}@localhost"}"; shift

  # LOCAL: eval the out to be able to check for substitute
  set +x; printf "\n\n%s\n" ":::::::: eval ${thing}" &>/dev/stderr; set -x
  out="$(nix "${nixargs[@]}" eval "${evalargs[@]}" --raw "${thing}")"

  # TARGET: return if we can realize on target
  set +x; printf "\n\n%s\n" ":::::::: trying to realize ${out} on ${target}" &>/dev/stderr; set -x
  if ssh_nix_unstable "${target}" nix "${nixargs[@]}" build "${buildargs[@]}" -j0 "${out}"; then
    echo -e "${out}"; return 0
  fi

  # LOCAL: eval the drvPath to build the derivation
  set +x; printf "\n\n%s\n" ":::::::: eval '${thing}.drvPath'" &>/dev/stderr; set -x
  local drv="$(set -euo pipefail; nix "${nixargs[@]}" eval "${evalargs[@]}" --raw "${thing}.drvPath")"

  # LOCAL: copy drvs to tmp
  local t="/tmp/tmpnixpath"
  nix "${nixargs[@]}" copy --to "file://${t}" --derivation "${drv}"

  # LOCAL->REMOTE: rsync drvs
  set +x; printf "\n\n%s\n" ":::::::: rsync ${t} to ${remote}" &>/dev/stderr; set -x

  rsync -ah "${t}/" "${remote}:${t}"

  # REMOTE: copy drvs to store
  ssh_nix_unstable "${remote}" nix "${nixargs[@]}" copy --from file://${t} --derivation ${drv}

  # REMOTE: build
  set +x; printf "\n\n%s\n" ":::::::: build ${drv} on ${remote}" &>/dev/stderr; set -x

####
  #ssh_nix_unstable "${remote}" nix "${nixargs[@]}" build -L "${buildargs[@]}" --keep-going "${drv}"
####
  ssh_niche_build "${remote}" niche build "${niche_cache}" -- -L "${nixargs[@]}"  "${buildargs[@]}" --keep-going "${drv}"
####

  if [[ ! -z "${cachixkey:-""}" ]]; then
    # REMOTE: push $out to cachix
    set +x; printf "\n\n%s\n" ":::::::: pushing ${out} to cachix" &>/dev/stderr; set -x

    ssh_cachix_path "${remote}" "${out}"
  fi

  # if we didn't list a target, we're just pushing the build up, we can be done
  if [[ -z "${target:-""}" ]]; then
    echo -e "${out}"; return 0
  fi

  if [[ ! -z "${USE_CACHIX:-""}" ]]; then
    # TARGET: realize from cachix (if it has internet and USE_CACHIX)
    set +x; printf "\n\n%s\n" ":::::::: trying to realize ${out} (from cache) on ${target}" &>/dev/stderr; set -x

    ssh_nix_unstable "${target}" nix "${nixargs[@]}" build "${buildargs[@]}" -j0 "${out}"
    #fi
  fi

  # TARGET: copy from builder (if it has internet)
  set +x; printf "\n\n%s\n" ":::::::: copying ${out} from ${remote} on ${target}" &>/dev/stderr; set -x

  if ssh -A "${target}" "$(printf '\"%s\" ' nix copy --from "ssh://${remote}" "${out}")"; then
    echo -e "${out}"; return 0
  fi

  # if we still cna't realize on device,
  # see if we can realize here and then push to device
  # (this applies for blueline where we cant pull but can be pushed to)
  if [[ ! -z "${cachixkey:-""}" ]]; then
    set +x; printf "\n\n%s\n" ":::::::: trying to realize ${out} (from cache)" &>/dev/stderr; set -x

    nix "${nixargs[@]}" build "${buildargs[@]}" "${thing}" -j0
  else
    set +x; printf "\n\n%s\n" ":::::::: manually copy ${out} from ${remote}" &>/dev/stderr; set -x

    nix "${nixargs[@]}" copy --from "ssh://${remote}" "${out}"
  fi

  # now that we have $out here, we can push to remote
  set +x; printf "\n\n%s\n" ":::::::: manually copy ${out} to ${target}" &>/dev/stderr; set -x

  nix "${nixargs[@]}" copy --to "ssh://${target}" "${out}"

  echo -e "${out}"; return 0
}

function activate() {
  set -euo pipefail
  local bo="$(set -euo pipefail; build "${@}")"
  local target="${3:-"cole@localhost"}"

  ssh -A "${target}" "$(printf '\"%s\" ' sudo nix build --profile /nix/var/nix/profiles/system "${bo}")";
  ssh -A "${target}" "$(printf '\"%s\" ' sudo nix shell -vv "${bo}" -c switch-to-configuration switch)";
}

function repro() {
  local thing="${1:-".#hosts.$(hostname)"}";

  nix build --out-link "/tmp/nixcfg_local" "${buildargs[@]}" "${evalargs[@]}" "${thing}"
  local out_local="$(readlink -f /tmp/nixcfg_local)"

  nix build --out-link "/tmp/nixcfg_github" "${buildargs[@]}" "github:colemickens/nixcfg#${thing:2}"
  local out_github="$(readlink -f /tmp/nixcfg_github)"

  nix flake update --no-registries --recreate-lock-file
  nix build --out-link "/tmp/nixcfg_locked" "${buildargs[@]}" "${thing}"
  local out_locked="$(readlink -f /tmp/nixcfg_locked)"

  set +x; echo; echo; echo;
  echo "out (flake.lock): ${out_locked}"
  echo "out (local repo): ${out_local}"
  echo "out     (github): ${out_github}"

  if [[ "${out_locked}" != "${out_local}" ]]; then
    exit -1
  fi
}

## nixup

if [[ ! -z "${1:-""}" ]]; then cmd="${1}"; shift; fi

if [[ ! -z "${cmd:-""}" ]]; then
  "${cmd}" "${@}"
else
  set -euo pipefail
  update
  activate ".#toplevels.$(hostname)" "cole@localhost" "cole@localhost"
fi
