#! /usr/bin/env nix-shell
#! nix-shell -i bash shell.nix
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
set -euo pipefail
set -x

unset NIX_PATH

cd "${DIR}"
mode="default"
host="$(hostname)"

[[ "${1:-""}" != "" ]]       && mode="${1}"     && shift

function nix() {
  if [[ "${1:-""}" == "sudo" ]]; then command sudo nix --experimental-features 'nix-command flakes' --pure-eval --show-trace "${@:2}"
  else command nix --experimental-features 'nix-command flakes' --pure-eval --show-trace "${@}"; fi
}

function nixbuild() { #TIHI: thanks, i hate it
  t="$(mktemp -d)"; link="${t}/out"
  if [[ "${1:-""}" == "sudo" ]]; then nix sudo build --out-link "${link}" "${@:2}"
  else nix build --out-link "${link}" "${@}"; fi
  tl="$(readlink -f ${link})"; rm -rf "${t}"
  echo -e "${tl}"
}

function update() {
  # our upstreams
  (cd "./scripts" && ./rebase-imports.sh)

  # flakes
  nix flake update --no-registries
  # WTF? Why does this ever have an effect? Needs to allow for more aggression
  nix flake update --no-registries --update-input home
  nix flake update --no-registries --update-input cmpkgs
  nix flake update --no-registries --update-input construct
  nix flake update --no-registries --update-input hardware
  #nix flake update --no-registries --update-input mozilla
  nix flake update --no-registries --update-input pipkgs
  nix flake update --no-registries --update-input wayland

  # legacy .imports
  (cd "./.imports" && ./update.sh)
}

function dev() {
  nix develop
}

function flakes() {
  # lol nix wrapper for output store paths
  if [[ "${1:-""}" == "local" ]]; then
    shift
    tl="$(set -e; nixbuild \
      --override-input master "/home/cole/code/nixpkgs/master" \
      --override-input cmpkgs "/home/cole/code/nixpkgs/cmpkgs" \
      --override-input pipkgs "/home/cole/code/nixpkgs/pipkgs" \
      --override-input hardware "/home/cole/code/extras/nixos-hardware" \
      --override-input wayland  "/home/cole/code/overlays/nixpkgs-wayland" \
        ".#nixosConfigurations.${host}.config.system.build.toplevel")"
    nix-store -q --graph "${tl}" > /tmp/nixos-flakes-local; echo -e "${tl}" > /tmp/nixos-flakes-local-out
  else
    tl="$(set -e; nixbuild ".#nixosConfigurations.${host}.config.system.build.toplevel")"
    nix-store -q --graph "${tl}" > /tmp/nixos-flakes; echo -e "${tl}" > /tmp/nixos-flakes-out
  fi

  if [[ "${1:-""}" == "switch" ]]; then
    nixbuild sudo \
      --experimental-features 'nix-command flakes' \
      --profile /nix/var/nix/profiles/system \
        ".#nixosConfigurations.${host}.config.system.build.toplevel"
    nix sudo shell -vv "${tl}" -c switch-to-configuration "${1}"
  fi
}

function legacy() {
  tl="$(set -e; nix-build --show-trace "./machines/${host}")"
  nix-store -q --graph "${tl}" > /tmp/nixos-legacy
  echo -e "${tl}" > /tmp/nixos-legacy-out

  if [[ "${1:-""}" == "switch" ]]; then
    sudo bash -c "\
      nix-env --set --profile /nix/var/nix/profiles/system ${tl} \
      && ${tl}/bin/switch-to-configuration ${1}"
  fi
}

# sadly, this is considerably faster than
# using nix and its usual remote building functionality
function remote() {
  machine="${1}"; shift
  remote="${1}"; shift

  #drv="$(nix eval --pure-eval ".#nixosConfigurations.${machine}.config.system.build.toplevel")" # TODO: why????
  drv="$(set -e; nix-instantiate "machines/${machine}")"
  out="$(set -e; nix show-derivation "${drv}" | jq -r 'to_entries[].value.outputs.out.path')" # TODO: must be a better way # (in v1, there's nix-store query that works)

  ## COPY DRV
  t="/tmp/tmpnixpath"; rm -rf "${t}"; trap "rm -rf $t" EXIT;
  nix-shell -I nixpkgs=https://github.com/nixos/nixpkgs/archive/nixos-unstable.tar.gz -p nix --command "nix copy --to file://${t} ${drv}" # see: https://github.com/NixOS/nix/issues/3696
  rsync -avh "${t}/" "${remote}:${t}"
  ssh "${remote}" "nix --experimental-features 'nix-command' copy --from file://${t} ${drv}"

  ## BUILD
  ssh "${remote}" \
    "nix-shell -I nixpkgs=https://github.com/nixos/nixpkgs/archive/nixos-unstable.tar.gz -p nixFlakes --command \
      \"nix build --experimental-features 'nix-command flakes' --pure-eval \
        --option 'extra-binary-caches' 'https://cache.nixos.org https://colemickens.cachix.org https://nixpkgs-wayland.cachix.org' \
        --option 'trusted-public-keys' 'cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= colemickens.cachix.org-1:bNrJ6FfMREB4bd4BOjEN85Niu8VcPdQe4F4KxVsb/I4= nixpkgs-wayland.cachix.org-1:3lwxaILxMRkVhehr5StQprHdEo4IrE8sRho9R9HOLYA=' \
        --option 'build-cores' '0' \
        --option 'narinfo-cache-negative-ttl' '0' --keep-going ${drv}\""

  ## PUSH TO CACHIX
  cache="colemickens"
  cachixkey="$(set -e; gopass show "websites/cachix.org/apikey/${cache}")"
  ssh "${remote}" \
    "nix-shell -I nixpkgs=https://github.com/nixos/nixpkgs/archive/nixos-20.03.tar.gz -p cachix --command \
      \"echo ${out} | env CACHIX_SIGNING_KEY=${cachixkey} cachix push ${cache}\""

  ## REALIZE FROM CACHIX
  nix-store \
    --option 'extra-binary-caches' 'https://cache.nixos.org https://colemickens.cachix.org https://nixpkgs-wayland.cachix.org' \
    --option 'trusted-public-keys' 'cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= colemickens.cachix.org-1:bNrJ6FfMREB4bd4BOjEN85Niu8VcPdQe4F4KxVsb/I4= nixpkgs-wayland.cachix.org-1:3lwxaILxMRkVhehr5StQprHdEo4IrE8sRho9R9HOLYA=' \
    -r "${out}"
}

function deploy() {
  machine="${1}"; shift
  remote="${1}"; shift
  drv="$(set -e; nix-instantiate "machines/${machine}")"
  tl="$(set -e; nix show-derivation "${drv}" | jq -r 'to_entries[].value.outputs.out.path')" # TODO: must be a better way (see above)
  nix copy --to "ssh-ng://${remote}" "${tl}"
  ssh "${remote}" "\
    sudo bash -c \"\
      nix-env --set --profile /nix/var/nix/profiles/system ${tl} \
      && ${tl}/bin/switch-to-configuration switch\""
}

function default() {
  set +x; echo "*************** UPDATE"
  time update
  set +x; echo "*************** LEGACY"
  time legacy
  #set +x; echo "*************** FLAKE LOCAL"
  #time flakes local
  # local blocked on: https://github.com/NixOS/nix/issues/3774
  set +x; echo "*************** FLAKE"
  time flakes
  set +x; echo "*************** SWITCH"
  time flakes switch
  set +x; echo "*************** DONE"

  set +x; echo "***************"
  echo "legacy: $(set -e; cat /tmp/nixos-legacy-out)"
  #echo "flocal: $(set -e; cat /tmp/nixos-flakes-local-out)"
  echo "flakes: $(set -e; cat /tmp/nixos-flakes-out)"
  set +x; echo "***************"
}

time "${mode}" "${@}"
